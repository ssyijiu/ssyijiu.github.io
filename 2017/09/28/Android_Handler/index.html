<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一. What、Handler 是什么Handler 与 Message、MessageQueue、Looper 一起构成了 Android 的消息机制，Android 系统通过大量的消息来与用户进行交互，View 的绘制、点击事件、Activity 的生命周期回调等都作为消息由主线程的 Handler 来处理。
Handler 在消息机制中的作用是：发送和处理消息。
Handler 还有另一个重">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Handler 消息机制详述">
<meta property="og:url" content="http://ssyijiu.com/2017/09/28/Android_Handler/index.html">
<meta property="og:site_name" content="ssyijiu'home">
<meta property="og:description" content="一. What、Handler 是什么Handler 与 Message、MessageQueue、Looper 一起构成了 Android 的消息机制，Android 系统通过大量的消息来与用户进行交互，View 的绘制、点击事件、Activity 的生命周期回调等都作为消息由主线程的 Handler 来处理。
Handler 在消息机制中的作用是：发送和处理消息。
Handler 还有另一个重">
<meta property="og:image" content="http://obe5pxv6t.bkt.clouddn.com/main_thread.png">
<meta property="og:updated_time" content="2018-02-23T08:18:43.162Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Handler 消息机制详述">
<meta name="twitter:description" content="一. What、Handler 是什么Handler 与 Message、MessageQueue、Looper 一起构成了 Android 的消息机制，Android 系统通过大量的消息来与用户进行交互，View 的绘制、点击事件、Activity 的生命周期回调等都作为消息由主线程的 Handler 来处理。
Handler 在消息机制中的作用是：发送和处理消息。
Handler 还有另一个重">
<meta name="twitter:image" content="http://obe5pxv6t.bkt.clouddn.com/main_thread.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ssyijiu.com/2017/09/28/Android_Handler/"/>





  <title> Android Handler 消息机制详述 | ssyijiu'home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ssyijiu'home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ssyijiu.com/2017/09/28/Android_Handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ssyijiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://obe5pxv6t.bkt.clouddn.com/ssyijiu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ssyijiu'home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android Handler 消息机制详述
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-28T00:00:00+08:00">
                2017-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一-What、Handler-是什么"><a href="#一-What、Handler-是什么" class="headerlink" title="一. What、Handler 是什么"></a>一. What、Handler 是什么</h3><p>Handler 与 Message、MessageQueue、Looper 一起构成了 Android 的消息机制，Android 系统通过大量的消息来与用户进行交互，View 的绘制、点击事件、Activity 的生命周期回调等都作为消息由主线程的 Handler 来处理。</p>
<p>Handler 在消息机制中的作用是：发送和处理消息。</p>
<p>Handler 还有另一个重要的作用，跨线程通信。最常见的就是子线程请求网络，然后使用 Handler 将请求到的数据 post 到主线程刷新 UI，大名鼎鼎的 Retrofit 也是这么做的。</p>
<h3 id="二-How、如何使用-Handler"><a href="#二-How、如何使用-Handler" class="headerlink" title="二. How、如何使用 Handler"></a>二. How、如何使用 Handler</h3><ul>
<li><p>创建 Handler </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">  <span class="comment">// 重写 handleMessage 来根据不同 what 来处理 Message</span></div><div class="line">  <span class="comment">// 这个方法在 Handler 创建的线程执行</span></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">              MLog.i(msg.obj);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>创建并发送 Message</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取一个 Message</span></div><div class="line">Message message = Message.obtain();</div><div class="line">message.what = <span class="number">0</span>;</div><div class="line">message.obj = <span class="keyword">new</span> Object();</div><div class="line"><span class="comment">// 使用 Handler 发送 Message</span></div><div class="line"><span class="comment">// 消息发送完成后 Handler 的 handleMessage(Message msg) 会处理消息</span></div><div class="line">handler.sendMessage(message);</div><div class="line"></div><div class="line"><span class="comment">// 延迟 1s 发送 Message</span></div><div class="line">handler.sendMessageDelayed(message, <span class="number">1000</span>);</div><div class="line"><span class="comment">// 发送一个空的 Message</span></div><div class="line">handler.sendEmptyMessage(msg.what);  </div><div class="line"><span class="comment">// 延迟发送一个空的 Message</span></div><div class="line">handler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">1000</span>);</div><div class="line"></div><div class="line"><span class="comment">// 还可以这样</span></div><div class="line"><span class="comment">// 创建 Message 并绑定 Handler</span></div><div class="line">Message message = handler.obtainMessage();</div><div class="line">message.what = <span class="number">0</span>;</div><div class="line">message.obj = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line"><span class="comment">// 发送 Message</span></div><div class="line">message.sendToTarget();</div></pre></td></tr></table></figure>
</li>
<li><p>使用 Handler 子线程请求数据，主线程刷新 UI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 在主线程创建 Handler（略）</span></div><div class="line"><span class="comment">// 2. 子线程请求数据，主线程刷新 UI</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取网络数据</span></div><div class="line">        <span class="keyword">final</span> List&lt;Object&gt; datas = getNetData();</div><div class="line"></div><div class="line">        <span class="comment">// 方法一：将数据作为 Message 的 obj 发送出去，在 handleMessage 中刷新 UI</span></div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = <span class="number">1</span>;</div><div class="line">        msg.obj = data;</div><div class="line">        handler.sendMessage(msg);</div><div class="line"></div><div class="line">        <span class="comment">// 方法二：直接在 post 中刷新 UI</span></div><div class="line">        handler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              <span class="comment">// 使用 datas 刷新 UI</span></div><div class="line">              <span class="comment">// 这个方法也会在 Handler 创建的线程执行</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三-Handler-的内存泄漏"><a href="#三-Handler-的内存泄漏" class="headerlink" title="三. Handler 的内存泄漏"></a>三. Handler 的内存泄漏</h3><p>不得不说，上面使用 Handler 的方法会有内存泄漏的风险</p>
<ul>
<li><p>Handler 内存泄漏的两个原因</p>
<ul>
<li><p>Java 中非静态内部类和匿名内部类会持有外部类的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是一个外部类 Handler 不会持有外部类引用</span></div><div class="line"><span class="comment">// 显然 handleMessage 没地方写了</span></div><div class="line">Handler handler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="comment">// 重写 handleMessage 后将得到一个内部类 Handler，以内 handleMessage 是在外部类中实现的</span></div><div class="line"><span class="comment">// 它持有外部类引用，可能会引起内存泄漏</span></div><div class="line">Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">              MLog.i(msg.obj);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这里 Handler 是一个匿名类，但不是内部类</span></div><div class="line"><span class="comment">// Runnable 是一个匿名内部类，持有外部类引用，可能会引起内存泄漏</span></div><div class="line"><span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>Handler 的生命周期比外部类长。</p>
</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>非静态的内部 Handler 子类、匿名 Handler 子类会持有外部类的引用(Activity)，而 Handler 可能会因为要等待处理耗时操作导致存活时间超过 Activity，或者消息队列中存在未被 Looper 处理的 Message ，而 Message 会持有 Handler 的引用。于是，在 Activity 退出时，其引用还是被 Handler 持有，导致 Activity 无法被及时回收，造成内存泄露。</li>
<li>非静态的内部 Runnable 子类、匿名 Runnable 子类 post 到任意 Handler 上时，Runnable 其实是 Massage中的 Callback，持有 Message 引用，如果这个 Massage 在消息队列还没有被处理，那么就会造成 Runnable 一直持有外部类的引用而造成内存泄露。</li>
</ul>
</li>
<li><p>解决方案：</p>
<ul>
<li>通过静态内部类或者外部类来声明 Handler 和 Runnable。</li>
<li>通过弱引用来拿到外部类的变量。</li>
<li>在 Activity/Fragment 销毁的时候请空 MessageQueue 中的消息。</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Handler 弱引用封装</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafetyHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 外部引用, 例如 Activity, Fragment, Dialog, View 等</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> WeakReference&lt;T&gt; mTargetRef;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafetyHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafetyHandler</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mTargetRef = <span class="keyword">new</span> WeakReference&lt;&gt;(target);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isTargetAlive()) &#123;</div><div class="line">            <span class="keyword">return</span> mTargetRef.get();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(T target)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mTargetRef = <span class="keyword">new</span> WeakReference&lt;&gt;(target);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTargetAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mTargetRef != <span class="keyword">null</span> &amp;&amp; mTargetRef.get() != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 Fragment 中使用方法</span></div><div class="line"><span class="comment">// 想重写 handleMessage 的话，要创建静态内部类或者外部类，否则有内存泄漏风险</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">SafetyHandler</span>&lt;<span class="title">MyFragment</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    MyHandler(MyFragment fragment) &#123;</div><div class="line">      	<span class="keyword">super</span>(fragment);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">        <span class="keyword">if</span>(getTarget() != <span class="keyword">null</span>) &#123;</div><div class="line">            MyFragment fragment = getTarget();</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">               <span class="comment">// 操作 fragment</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 声明 Handler</span></div><div class="line">MyHandler handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">// 使用 Handler</span></div><div class="line">handler.sendMessage() ...</div><div class="line">  </div><div class="line"><span class="comment">// onDestroy   </span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="四-Why、Handler-消息机制的原理"><a href="#四-Why、Handler-消息机制的原理" class="headerlink" title="四. Why、Handler 消息机制的原理"></a>四. Why、Handler 消息机制的原理</h3><blockquote>
<p>这部分从 ActivityThread 的 main 方法出发，打通整个消息机制的流程，结合源码体验效果更佳。</p>
</blockquote>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>介绍消息机制的原理前，我们先来看一下 Handler 与 Message、MessageQueue、Looper 这个四个类的作用</p>
<ul>
<li>Handler：前面已经说过，Handler 负责发送和处理 Message。</li>
<li>Message：消息，负责传递标示(what) 和数据(obj) ；每个 Message 都会通过 target 这个成员变量来绑定一个 Handler，由这个 Handler 来发送和处理 Message。</li>
<li>MessageQueue：消息队列，负责存放有 Handler 发送过来的消息；每个 Handler 中都有一个 final MessageQueue mQueue，Handler 发送消息就是把消息加入这个 MessageQueue 。</li>
<li>Looper：负责不断的从 MessageQueue 中取出消息然后交给 Handler（Message#target ） 处理；每个 Looper 中都有一个唯一的消息队列（final MessageQueue mQueue），每个 Handler 中都有一个 final Looper mLooper，Handler 中的 MessageQueue 就是来自 Looper。</li>
</ul>
<p>注意：每个线程只能有一个 Looper 和 一个 MessageQueue，可以有多个 Handler，每个 Handler 可以发送和处理多个 Message。</p>
<p>另外，提到消息机制就不得不说一下 Android 中的主线程（UI 线程）</p>
<p><img src="http://obe5pxv6t.bkt.clouddn.com/main_thread.png" alt=""></p>
<p>Android 中的主线程通过 Looper.loop() 进入一个无线循环中，不断的从一个 MessageQueue 取出消息，处理消息，我们每触发一个事件，就会向这个 MessageQueue 中添加一个消息，Looper 取出这个消息，Handler 处理这个消息，正是 Looper.loop()  在驱动着 Android 应用运行下去 ，这也是为什么 Looper.loop 为什么不会阻塞住主线程的原因（当然前提是在 ActivityThread 的 main 函数 中调用）。</p>
<h4 id="正式进入源码分析"><a href="#正式进入源码分析" class="headerlink" title="正式进入源码分析"></a>正式进入源码分析</h4><blockquote>
<p>本源码分析基于 API 25，以下源码中删除了一些无关的代码</p>
</blockquote>
<p>1、在主线程的入口，ActivityThread 的 main 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 准备主线程的 Looer		</span></div><div class="line">        Looper.prepareMainLooper();</div><div class="line">        <span class="comment">// 创建 ActivityThread</span></div><div class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">        thread.attach(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 获取主线程的 Handler </span></div><div class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">            sMainThreadHandler = thread.getHandler();</div><div class="line">        &#125;</div><div class="line">  </div><div class="line">        <span class="comment">// 对消息队列进行无线轮询，处理消息</span></div><div class="line">        Looper.loop();</div><div class="line">	    <span class="comment">// 一旦跳出循环，抛出异常（Android 不允许跳出主线程的 Looper.loop()）</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt; Looper.prepareMainLooper()</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 准备一个 Looper</span></div><div class="line">        prepare(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">            <span class="comment">// main Looper 只能初始化一次，再次初始化会抛出异常</span></div><div class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 获取 main Looper</span></div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>-&gt; prepare(false)</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 准备一个 Looper，quitAllowed 是否允许 Looper 中的 MessageQueue 退出</span></div><div class="line"><span class="comment">// 默认 prepare() 允许退出，主线程这里不允许退出</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">      <span class="comment">// 先看下 sThreadLocal 是什么</span></div><div class="line">      <span class="comment">// static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span></div><div class="line">      <span class="comment">// ThreadLocal:线程本地存储区，每个线程都有本地存储区域，这个区域是每个线程私有的，不同的线程不能之间不能彼此访问</span></div><div class="line">      <span class="comment">// 如果 sThreadLocal 中有数据，抛出异常，换句话说 prepare() 这个函数每个线程只能执行一次</span></div><div class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 创建 Looper 保存到该线程的 ThreadLocal 中</span></div><div class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt; new Looper(quitAllowed)</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">      <span class="comment">// 在 Looper 创建的时候创建一个消息队列</span></div><div class="line">      <span class="comment">// quitAllowed:消息队列是否可以退出，主线的消息队列肯定不允许退出，所以上面是 prepare(false)</span></div><div class="line">      <span class="comment">// quitAllowed 为 false 执行 MessageQueue#quit 退出消息队列时会出现异常</span></div><div class="line">      mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">      <span class="comment">// 获取 Looper 存在于哪个线程</span></div><div class="line">      mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt; sMainLooper = myLooper()</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// 从 sThreadLocal 中获取当前线程的 Looper </span></div><div class="line">      <span class="comment">// 如果当前线程没有掉用 Looper.prepare 返回 null</span></div><div class="line">      <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt;  sMainThreadHandler = thread.getHandler();</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// 返回 mH</span></div><div class="line">      <span class="keyword">return</span> mH;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// mH 在成员变量的位置 new H()</span></div><div class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</div><div class="line"></div><div class="line"><span class="comment">// H 继承了 Handler 封装了一系列关于 Acitivty、Service 以及其他 Android 相关的操作</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></div></pre></td></tr></table></figure>
<p>总结：在主线程的 main 方法中，会创建主线程的 Looper、MessageQueue，然后进入 Looper.loop() 循环中，不断的取出消息，处理消息，以此来驱动 Android 应用的运行。</p>
<p>2、Handler 的创建，Handler 的所有构造方法都会跳转到下面两个之一</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="comment">// Hanlder 是匿名类、内部类、本地类时，如果没有声明为 static 则会出现内存泄漏的警告</span></div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">            (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">          	Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> + klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 获取 Looper</span></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 消息队列，从 Looper 中获取</span></div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    <span class="comment">// 处理消息的回调接口</span></div><div class="line">    mCallback = callback;</div><div class="line">    <span class="comment">// 处理消息的方式是否为异步，默认同步</span></div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">      mLooper = looper;</div><div class="line">      mQueue = looper.mQueue;</div><div class="line">      mCallback = callback;</div><div class="line">      mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：在 Handler 的构造方法中，Handler 和 Looper、MessageQueue 绑定起来，如果当前线程没有 Looper 抛出异常（这也是为什么直接在子线程创建 Handler 会出现异常）。</p>
<p>3、使用 Handler 发送消息</p>
<p>-&gt; sendMessageAtTime(Message msg, long uptimeMillis)</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 除了 sendMessageAtFrontOfQueue，Handler 所有的 post、sendMessage 都会跳到这个方法</span></div><div class="line"><span class="comment">// Message msg: 要发送的消息</span></div><div class="line"><span class="comment">// long uptimeMillis: 发送消息的绝对时间，通过 SystemClock.uptimeMillis() 加上我们自己的延迟时间 delayMillis 计算而来</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">      MessageQueue queue = mQueue;</div><div class="line">      <span class="comment">// 消息队列为空（可能已经退出）返回 false 入队失败</span></div><div class="line">      <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">          RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">          Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 消息入队</span></div><div class="line">      <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt; sendMessageAtFrontOfQueue(Message msg)</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 发送消息到 MessageQueeu 的队头</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      MessageQueue queue = mQueue;</div><div class="line">      <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">          RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">          Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 通过设置 uptimeMillis 为 0，是消息加入到 MessageQueue 的队头</span></div><div class="line">      <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt; enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 所有 Handler 的 post 、sendMessage 系列方法和 runOnUiThread 最终都会调用这个方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">      <span class="comment">// msg.target 是一个 Handler，将 Message 和 Handler 绑定</span></div><div class="line">      <span class="comment">// 也就是用哪个 Handler 发送消息，这个 Message 就和哪个 Handler 绑定</span></div><div class="line">      msg.target = <span class="keyword">this</span>;</div><div class="line">      <span class="comment">// 如果设置了消息处理方式为异步处理</span></div><div class="line">      <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        	msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// MessageQueue 的方法，将消息入队</span></div><div class="line">      <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>-&gt;  MessageQueue#enqueueMessage(Message msg, long when)</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        <span class="comment">// Messgae 没有绑定 Handler 抛出异常</span></div><div class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// Messgae 正在使用 抛出异常</span></div><div class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">        &#125;</div><div class="line">	</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">// 消息队列正在退出，回收 Message</span></div><div class="line">            <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();  <span class="comment">// 调用 Message#recycleUnchecked() </span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            msg.markInUse();  <span class="comment">// 标记 Message 正在使用</span></div><div class="line">            msg.when = when;  <span class="comment">// 设置 Message 的触发时间</span></div><div class="line">          </div><div class="line">            <span class="comment">// mMessages 记录着 MessageQueue 的队头的消息 </span></div><div class="line">            Message p = mMessages;  </div><div class="line">            <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="comment">// MessageQueue 没有消息、Message 触发时间为 0、Messgae 触发时间比队头 Message 早</span></div><div class="line">            <span class="comment">// 总之这个 Message 在 MessageQueue 中需要最先被分发</span></div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">                msg.next = p;     <span class="comment">// 将以前的队头 Message 链接在这个 Message 后面</span></div><div class="line">                mMessages = msg;  <span class="comment">// 将这个 Message 赋值给 mMessages</span></div><div class="line">                needWake = mBlocked;  <span class="comment">// 队列是否阻塞</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 标记队列是否阻塞</span></div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">              </div><div class="line">                <span class="comment">// 按照时间顺序将 Message 插入消息队列</span></div><div class="line">                <span class="keyword">for</span> (;;) &#123;</div><div class="line">                    prev = p;   <span class="comment">// prev 记录队头</span></div><div class="line">                    p = p.next; <span class="comment">// p 记录队头的后一个</span></div><div class="line">                    <span class="comment">// 队头后面没有消息或者其触发事件比要插入的 Message 晚，跳出循环</span></div><div class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 将 Message 插入队列</span></div><div class="line">                msg.next = p; </div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">            <span class="keyword">if</span> (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>总结：到现在为止，我们的 Handler 已经将 Message 发送到了 MessageQueue，Message 静静的等待被处理。</p>
<p>4、Looper.loop() 还记得这个方法在 ActivityThread 的 main 调用了吗？正是它在不断处理 MessageQueue 里面的消息。</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 获取 Looper.Looper.prepare 准备好的 Looper</span></div><div class="line">       <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">       <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获取 Looper 中的消息队列</span></div><div class="line">       <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">  </div><div class="line">       <span class="comment">// 进入无线循环</span></div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           <span class="comment">// 取出下一条消息</span></div><div class="line">           Message msg = queue.next(); </div><div class="line">           </div><div class="line">           <span class="comment">// 没有消息，退出 loop</span></div><div class="line">           <span class="comment">// 其实上面 queue.next() 也是一个无限循环，获取到消息就返回，没有消息就一直循环</span></div><div class="line">           <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// msg.target 实际上就是一个 Handler</span></div><div class="line">               <span class="comment">// 获取到了消息，使用绑定的 Handler#dispatchMessage 分发消息</span></div><div class="line">               msg.target.dispatchMessage(msg);</div><div class="line">           &#125; <span class="keyword">finally</span> &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// 释放消息，把 Message 的各个变量清空然后放进消息池中</span></div><div class="line">           msg.recycleUnchecked();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>5、Handler#dispatchMessage(msg) 消息是如何处理的</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">    	handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 2</span></div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">    		<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">    			<span class="keyword">return</span>;</div><div class="line">    		&#125;</div><div class="line">    	&#125;</div><div class="line">        <span class="comment">// 3. 看到这个方法没有！就是我们创建 Handler 时重写的 handleMessage</span></div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：流程虽然通了，但是处理 Message 的方法貌似有三种(我标记了序号)，而且我们的 handleMessage 的优先级最低，其他方法会在什么情况下执行呢？ 直接说结论了，调用 Handler 的 post 系列方法会走序号1的处理，创建 Handler 传入 Callback 会走序号2 的处理。</p>
<p>Handler 机制总结：想使用 Handler 必须要有 Looper，创建 Looper 的时候会创建 MessageQueue，在 Handler 的构造的时候会绑定这个 Looper 和 MessageQueue，Handler 将 Message 发送到 MessageQueue 中，Looper.loop() 会不断的从 MessageQueue 取出消息再交给这个 Handler  处理。</p>
<h3 id="五-HandlerThread-的使用及源码解读"><a href="#五-HandlerThread-的使用及源码解读" class="headerlink" title="五. HandlerThread 的使用及源码解读"></a>五. HandlerThread 的使用及源码解读</h3><h4 id="在子线程中能直接创建-Handler-吗？"><a href="#在子线程中能直接创建-Handler-吗？" class="headerlink" title="在子线程中能直接创建 Handler 吗？"></a>在子线程中能直接创建 Handler 吗？</h4><ul>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              	MLog.i(<span class="string">"Handler in "</span> + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
</li>
<li><p>答案前面提到了是不能，执行上面的代码会出现 java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare() 这个异常，异常提示我们，不能再没有调用 Looper.prepare() 的线程中创建 Handler。</p>
</li>
<li><p>简单修改下代码就可以了，给线程准备好 Looper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 准备一个 Looper，Looper 创建时对应的 MessageQueue 也会被创建</span></div><div class="line">        Looper.prepare();</div><div class="line">        <span class="comment">// 创建 Handler 并 post 一个 Message 到 MessageQueue</span></div><div class="line">        <span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              	MLog.i(<span class="string">"Handler in "</span> + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">// Looper 开始不断的从 MessageQueue 取出消息并再次交给 Handler 执行</span></div><div class="line">        <span class="comment">// 此时 Lopper 进入到一个无限循环中，后面的代码都不会被执行</span></div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
</li>
<li><p>上面的操作 Android 都帮我们封装好了，正是 HandlerThread  这个类。</p>
</li>
</ul>
<h4 id="HandlerThread-的简单使用"><a href="#HandlerThread-的简单使用" class="headerlink" title="HandlerThread 的简单使用"></a>HandlerThread 的简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 创建 HandlerThread</span></div><div class="line">handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"myHandlerThread"</span>) &#123;</div><div class="line">    <span class="comment">// onLooperPrepared 这个方法子线程执行，由线程的 run 方法调用，可以在里面直接创建 Handler</span></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onLooperPrepared();</div><div class="line">        <span class="keyword">new</span> Handler().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 注意：Handler 在子线程创建，这个方法也会运行在子线程，不可以更新 UI</span></div><div class="line">              	MLog.i(<span class="string">"Handler in "</span> + Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2. 准备 HandlerThread 的 Looper 并调用 onLooperPrepared</span></div><div class="line">handlerThread.start();</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3. 退出</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    handlerThread.quit();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 也可以这样用</span></div><div class="line"><span class="comment">// 1. 创建 HandlerThread 并准备 Looper</span></div><div class="line">handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"myHandlerThread"</span>);</div><div class="line">handlerThread.start();</div><div class="line"></div><div class="line"><span class="comment">// 2. 创建 Handler 并绑定 handlerThread 的 Looper</span></div><div class="line"><span class="keyword">new</span> Handler(handlerThread.getLooper()).post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      	<span class="comment">// 注意：Handler 绑定了子线程的 Looper，这个方法也会运行在子线程，不可以更新 UI</span></div><div class="line">      	MLog.i(<span class="string">"Handler in "</span> + Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 3. 退出</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDestroy();</div><div class="line">    handlerThread.quit();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="HandlerThread-源码解读"><a href="#HandlerThread-源码解读" class="headerlink" title="HandlerThread 源码解读"></a>HandlerThread 源码解读</h4><ul>
<li><p>HandlerThread 继承了 Thread，本质是一个拥有 Looper 的线程，因此在 HandlerThread  我们可以直接使用 Handler。</p>
</li>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(name);</div><div class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传入线程的名称和优先级</span></div><div class="line"><span class="comment">// 注意 priority 的值必须来自 android.os.Process 不能来自 java.lang.Thread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(name);</div><div class="line">    mPriority = priority;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>run 方法：创建子线程的 Looper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    <span class="comment">// 准备一个 Looper</span></div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="comment">// 获取 Looper</span></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="comment">// Looper 获取成功后，唤醒 getLooper 的 wait</span></div><div class="line">        notifyAll();</div><div class="line">	&#125;</div><div class="line">	Process.setThreadPriority(mPriority);</div><div class="line">    <span class="comment">// Looper 准备好的回调，在这个方法里可以使用 Handler 了</span></div><div class="line">    onLooperPrepared();</div><div class="line">    <span class="comment">// Looper 开始循环取消息</span></div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>getLooper 方法：获取子线程的 Looper</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 线程没有开始或者死亡，返回 null</span></div><div class="line">  	<span class="keyword">if</span> (!isAlive()) &#123;</div><div class="line">      	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></div><div class="line">    <span class="comment">// Looper 的创建时在子线程完成的，而 getLooper 可能会在主线程调用</span></div><div class="line">    <span class="comment">// 当 Looper 没有创建完成时，使用 wait 阻塞等待</span></div><div class="line">    <span class="comment">// 上面在 Looper 创建好后会 notifyAll 来唤醒 wait</span></div><div class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mLooper;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>quit 和 quitSafely ：结束 Looper 的运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// quit</span></div><div class="line">quit() -&gt; looper.quit() -&gt; mQueue.quit(<span class="keyword">false</span>);</div><div class="line"><span class="comment">// quitSafely </span></div><div class="line">quitSafely() -&gt; looper.quitSafely() -&gt; mQueue.quit(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这两个方法最终都会调用到 MessageQueue 的 void quit(boolean safe) 方法</span></div><div class="line"><span class="comment">// 前者会直接移除 MessageQueue 中的所有消息，然后终止 MessageQueue</span></div><div class="line"><span class="comment">// 后者会将 MessageQueue 中已有消息处理完成后（不再接收新消息）终止 MessageQueue</span></div></pre></td></tr></table></figure>
<h3 id="六-参考文章"><a href="#六-参考文章" class="headerlink" title="六.参考文章"></a>六.参考文章</h3><ul>
<li>Android API 25 源码</li>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="external">Android消息机制1-Handler(Java层)</a></li>
</ul>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/23/Android_Runtime_Permissions/" rel="next" title="Android 6.0 运行时权限 总结 & 实践">
                <i class="fa fa-chevron-left"></i> Android 6.0 运行时权限 总结 & 实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/24/Think_Of_Buy_Coin/" rel="prev" title="炒币半年多的一点感受与经验">
                炒币半年多的一点感受与经验 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://obe5pxv6t.bkt.clouddn.com/ssyijiu.jpg"
               alt="ssyijiu" />
          <p class="site-author-name" itemprop="name">ssyijiu</p>
           
              <p class="site-description motion-element" itemprop="description">不负代码不负卿</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ssyijiu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/0dfb41dd9210" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                  JianShu
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-What、Handler-是什么"><span class="nav-number">1.</span> <span class="nav-text">一. What、Handler 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-How、如何使用-Handler"><span class="nav-number">2.</span> <span class="nav-text">二. How、如何使用 Handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-Handler-的内存泄漏"><span class="nav-number">3.</span> <span class="nav-text">三. Handler 的内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-Why、Handler-消息机制的原理"><span class="nav-number">4.</span> <span class="nav-text">四. Why、Handler 消息机制的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#正式进入源码分析"><span class="nav-number">4.2.</span> <span class="nav-text">正式进入源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-HandlerThread-的使用及源码解读"><span class="nav-number">5.</span> <span class="nav-text">五. HandlerThread 的使用及源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在子线程中能直接创建-Handler-吗？"><span class="nav-number">5.1.</span> <span class="nav-text">在子线程中能直接创建 Handler 吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HandlerThread-的简单使用"><span class="nav-number">5.2.</span> <span class="nav-text">HandlerThread 的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HandlerThread-源码解读"><span class="nav-number">5.3.</span> <span class="nav-text">HandlerThread 源码解读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-参考文章"><span class="nav-number">6.</span> <span class="nav-text">六.参考文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ssyijiu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
